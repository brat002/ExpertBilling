TRY USING weakref FOR DICTS IN nf

__debug__!!!
!! __resourse__ module
file:///D:/Python/http___gnosis.cx_publish_tech_index_cp.html/gnosis.cx/publish/programming/charming_python_b7.html
file:///D:/Python/http___gnosis.cx_publish_tech_index_cp.html/gnosis.cx/publish/programming/charming_python_b5.html

candygram!
http://candygram.sourceforge.net

Test Driven Development By Example (Addison-Wesley): 

!! add dumper signal

!!rewrite using genexps!
sum(x*x for x in xrange(10)) is a great way to express the sum of the squares of the first ten natural numbers


psycopg_exc = (psycopg2.ddsdsd, ps.ddd)
curslo = cursor
TRaceback.print_exc
back to queues

import inspect
import sys
version_23 = sys.version_info < (2, 4)
def this_list( ):
    import sys
    d = inspect.currentframe(1).f_locals
    nestlevel = 1
    while '_[%d]' % nestlevel in d: nestlevel += 1
    result = d['_[%d]' % (nestlevel - 1)]
    if version_23: return result._ _self_ _
    else: return result


import gc
def dump_garbage( ):
    """ show us what the garbage is about """
    # Force collection
    print "\nGARBAGE:"
    gc.collect( )
    print "\nGARBAGE OBJECTS:"
    for x in gc.garbage:
        s = str(x)
        if len(s) > 80: s = s[:77]+'...'
        print type(x),"\n  ", s
if _ _name_ _=="_ _main_ _":
    gc.enable( )
    gc.set_debug(gc.DEBUG_LEAK)
    # Simulate a leak (a list referring to itself) and show it
    l = [  ]
    l.append(l)
    del l
    dump_garbage( )


import sys, traceback
traceOutput = sys.stdout
watchOutput = sys.stdout
rawOutput = sys.stdout
# calling 'watch(secretOfUniverse)' prints out something like:
# File "trace.py", line 57, in _ _testTrace
#    secretOfUniverse <int> = 42
watch_format = ('File "%(fileName)s", line %(lineNumber)d, in' 
                ' %(methodName)s\n   %(varName)s <%(varType)s>' 
                ' = %(value)s\n\n')
def watch(variableName):
    if _ _debug_ _:
        stack = traceback.extract_stack( )[-2:][0]
        actualCall = stack[3]
        if actualCall is None:
            actualCall = "watch([unknown])"
        left = actualCall.find('(')
        right = actualCall.rfind(')')
        paramDict = dict(varName=actualCall[left+1:right]).strip( ),
                         varType=str(type(variableName))[7:-2],
                         value=repr(variableName),
                         methodName=stack[2],
                         lineNumber=stack[1],
                         fileName=stack[0])
        watchOutput.write(watch_format % paramDict)
# calling 'trace("this line was executed")' prints out something like:
# File "trace.py", line 64, in ?
#    this line was executed
trace_format = ('File "%(fileName)s", line %(lineNumber)d, in' 
                ' %(methodName)s\n   %(text)s\n\n')
def trace(text):
    if _ _debug_ _:
        stack = traceback.extract_stack( )[-2:][0]
        paramDict = dict(text=text,
                         methodName=stack[2],
                         lineNumber=stack[1],
                         fileName=stack[0])
        watchOutput.write(trace_format % paramDict)
# calling 'raw("some raw text")' prints out something like:
# Just some raw text
def raw(text):
    if _ _debug_ _:
        rawOutput.write(text)
        
        
back and forth if needed. This recipe exploits this structure and the rich amount of information held by frame objects, including, in particular, the dictionary of local variables for the function corresponding to each frame:

import sys, traceback
def print_exc_plus( ):
    """ Print the usual traceback information, followed by a listing of
        all the local variables in each frame.
    """
    tb = sys.exc_info( )[2]
    while tb.tb_next:
        tb = tb.tb_next
    stack = [  ]
    f = tb.tb_frame
    while f:
        stack.append(f)
        f = f.f_back
    stack.reverse( )
    traceback.print_exc( )
    print "Locals by frame, innermost last"
    for frame in stack:
        print
        print "Frame %s in %s at line %s" % (frame.f_code.co_name,
                                             frame.f_code.co_filename,
                                             frame.f_lineno)
        for key, value in frame.f_locals.items( ):
            print "\t%20s = " % key,
            # we must _absolutely_ avoid propagating exceptions, and str(value)
            # COULD cause any exception, so we MUST catch any...:
            try:
                print value
            except:
                print "<ERROR WHILE PRINTING VALUE>"



!!freezer - better use some C calls
!!!!rewrite all silent try/except with DEBUG


!!! nfroutine - check connections! if there\re database errors - save data into files!
!!!nf - if database errors - save data
-- save method - if exception - put data back into queue
monitor queues - length too big - send SLP!
add try/exc to ServiceThreads
add an option - save if no DB connection - use old caches etc
add a DumperThread which would dump data and be called if connection is restored
!!!periodicalservice tp - sqlfuns
!!!refactor ebs.sql
!!!grepper - blabla
!!!cache creator based on __slots__classes
!!!nf - nfroutine workflow article
!!!rewrite cache reread on SIGHUP

#python 2.6 check named tuples????? marshalable??



write an nf generator based on classes, ports, hops, etc
get from the db info
rad packet generator
testerov na adminku
grepper
testsuite
etc
code cleanup
!rewrite nf 
  10:26:11 PM yolta_ku: locale module
  10:27:18 PM yolta_ku: gettext module
  12:03:15 AM yolta_ku: di = sorted(d.iteritems(), key=itemgetter(0))
  12:18:02 AM yolta_ku: qsettings - tempdelete file
  12:35:29 AM yolta_ku: encode report  data into hash and seek recent!
save queues and pending data in core.py if database is down

'''
class Cacher(object):
    __slots__ = (execList, curATCache,curAT_acIdx,curAT_tfIdx, curSPCache, curTLimitCache, curSuspPerCache,
                 curNasCache,curTTSCache, curDefSpCache, curNewSpCache, curPerTarifCache, curPersSetpCache,
                 curTimeAccNCache, curTimePerNCache, curTimeAccSrvCache, )
    def __init__(self):
        pass
'''
  12:59:10 AM yolta_ku: remake report creating finctions - get data from bd in portions
store in file, calc start/end date, calc length - process
for paged reports - also! - select 2-4 pages!



TUNNEL PYRO THROUGH SSH! ?? for every client? hmmmm

Pyro.core.Daemon(host='127.0.0.1')
