Общее описание
--------------
Данный фризер позволяет создавать независимые
от интерпретатора приложения, написанные на
Питоне. Получаемые на выходе исполнимые файлы
содержат встроенную защиту от копирования, которая
работает по принципу сравнения лицензионного ключа
и ключа, генерируемого при идентификации технического
и программного окружени приложения.

Принцип работы фризера
----------------------
Фризеру передается имя файла главного скрипта
программы и ряд необязательных параметров, которые
могут уточнять метод сборки проекта. После этого
происходит поиск зависимых модулей. Локальные
модули, находящиеся в главной и поддиректориях
приложения, компилируются, упаковываются, шифруются
лицензионным ключом и объединяются с модулем
защиты, остальные копируются в <output directory>/modules,
которая при запуске добавляется в системный путь.
Полученный скрипт вновь компилируется, шифруется простым
алгоритмом и записывается в .c файл, который затем
компилируется и линкуется с библиотекой Питона.

Принцип работы защиты
---------------------
Лицензионный ключ представляет собой результат функции
md5.new(ARG).hexdigest(), где ARG является строкой-объединением
серийных номеров установленных жестких дисков, типа
платформы и содержания файла 'license.lic'. При запуске программы
происходит сбор данной информации. На ее основе описанным
выше способом генерируется ключ, которым дешифруются
модули приложения. Если это нелегальная копия программы,
модули будут дешифрованы неверно и не смогут быть
распакованы и загружены.

Замечания
---------
Ни в коем случае не следует рассчитывать не определенный
порядок загрузки модулей, так как они добавляются в sys.path
и исполняются в том порядке, в котором были обнаружены при
интроспекции.

Технические данные
------------------
Поддерживаемые версии Питона: CPython 2.4/2.5
Целевые платформы: Linux/BSD
Используемый компилятор: GCC
Тестировался под: Debian Etch

Варианты использования
----------------------
Возможны 3 способа сборки программы с помощью фризера.
В первом случае скрипт запускается из командной строки.
Ему передаются следующие параметры:
 -k KEY
	ключ которым шифруются модули
 --nloc=NAME[, NAME...]
	список имен модулей, которые находятся в
	директории программы и не должны или не
	могут быть "зафрижены" (к примеру динамические
	библиотеки)
 -i
	вынуждает фризер игнорировать необнаруженные
	зависимые модули
 --amods=MOD_NAME:[MOD_FILE][, MOD_NAME:[MOD_FILE]...]
	список пар, каждая из которых содержит
	имя зависимого модуля, который не может быть
	обнаружен при интроспекции, но так же должен быть
	включен в процесс сборки, и необязательное имя файла
 <PY_FILE>
	имя файла главного модуля программы
 <C_FILE>
	имя получаемого .С файла
При втором варианте фризер так же запускается из
командной строки, но без параметров. В этом случае
он работает как "make" - пытается прочитать файл
с именем "Freezefile" в текущей директории. Данный
файл является скриптом на языке Питон. Ключевыми
являются описанные в нем глобальные идентификаторы:
 PY_FILE
	строка с именем файла приложения
 C_FILE
	имя выходного файла
 PROTECTION_KEY
	строка ключа для шифровки
 IGNORE_MISSING
	True/False - пропускать ненайденные модули
 ADDITIONAL_MODULES
	словарь пар ИМЯ_МОДУЛЯ:(ИМЯ_ФАЙЛА | None),
	описывающий дополнительные модуля для сборки
	проекта
 NONLOCAL
	список имен модулей, которые не должны быть
	упакованы, а только скопированы в директорию
	проекта
И последний вариант - импорт фризера как модуля
и вызов функции freeze() со следующими аргументами:
 pyfile, cfile, key, ignoremissing, amods, nonlocal
